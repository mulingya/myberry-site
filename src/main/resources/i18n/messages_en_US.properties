#html
lang=en
#meta
content=A highly available distributed ID construction engine provides a set of standard ID construction services for enterprises and organizations.
#nav
wellcome=Wellcome
quickstart=Quick Start
documentation=Documentation
license=License
design=Design
practice=PRACTICE
dev=Dev
ops=Ops
performance=Performance
faq=FAQ
thanks=Thanks
#wellcome content
wellcome.title=Wellcome to MyBerry
wellcome.introduction=MyBerry is a distributed ID construction engine. The MyBerry service manages and builds IDs in a format that is configurable, easy to operate, and guaranteed to be unique.If you think MyBerry can help with your project, you can find more information about MyBerry in the navigation section to get some insight into some of the main features.MyBerry is an completely free open source, distributed in the form of source code, provides ID building related functionality support for many industries and organizations.
wellcome.latest.released.title=Latest v2.2.0 Released
wellcome.latest.released.introduction=v2.2.0 upgrade to JDK17.
wellcome.latest.released.change1=Modified\uFF1AFully adapt to JDK17.
wellcome.waterfall.3.released.title=v2.1.0 Released
wellcome.waterfall.3.released.introduction=v2.1.0 has made some improvements and optimizations, which are more in line with the design concept of the current version.
wellcome.waterfall.3.released.change1=Deleted\uFF1ARemove NS component update.
wellcome.waterfall.3.released.change2=Optimization\uFF1AOptimize JVM parameters.
wellcome.waterfall.2.released.title=v2.0.1 Released
wellcome.waterfall.2.released.introduction=v2.0.1 fixes a high-risk bug in Logback.
wellcome.waterfall.2.released.change1=Fixed: Upgrade Logback, fix Logback bug.
wellcome.waterfall.1.released.title=v2.0.0 Released
wellcome.waterfall.1.released.introduction=v2.0.0 is the first official version of MyBerry, which reconstructs the underlying structure, comprehensively improves the features of MyBerry, and improves security and performance.
wellcome.waterfall.1.released.change1=Modified: The server merges the CR and NS structures, and the user determines the type of structure creation.
wellcome.waterfall.1.released.change2=Modified: File service supports file slicing.
wellcome.waterfall.1.released.change3=Modified: Refactored HA module.
wellcome.waterfall.1.released.change4=Added: myberry.properties supports data write-back. When the configuration in the memory changes, the new value is written back to the myberry.properties file.
wellcome.waterfall.1.released.change5=Added: LightCodec supports Set and Array.
wellcome.waterfall.1.released.change6=Modified: FastJSON is removed, and LightCodec completely replaces FastJSON.
wellcome.waterfall.1.released.change7=Added: The startup command adds "-v" to view the version number of the current instance.
wellcome.waterfall.1.released.change8=Deleted: The NoticeListener is deleted, and the system-level monitoring is decoupled.
wellcome.waterfall.1.released.change9=Added: The instance safely kicks out the routing features.
wellcome.waterfall.1.released.change10=Added: The features that the instance is removed from the cluster list.
wellcome.waterfall.1.released.change11=Added: Update routing weight.
wellcome.waterfall.1.released.change12=Added: NS structure update configuration.
wellcome.history.released.title=Get History Released
#quickstart
quickstart.guide=This quick start guide will help you quickly understand the main functions of MyBerry.
quickstart.maven=Add Dependency
quickstart.debug=Quick Debug
quickstart.debug.introduction=Create a new test class MyBerryTest, execute the following code, and view the results printed in the console, which will help you get a preliminary understanding of the main functions of MyBerry.
quickstart.spring=Spring Integration
quickstart.spring.introduction=If you are using the spring framework, you can easily integrate MyBerry into the spring framework.
quickstart.spring.admin=Spring integration administrator
quickstart.spring.user=Spring integration client
#documentation
documentation.description=You must understand which functions MyBerry supports, and the role of these functions in order to truly understand and put it into use. For this, you need to read the client API documentation carefully.
documentation.user.title=User-oriented
documentation.user.method.desc.sync.roundrobin.failfast=Pull an ID from the server. Synchronous call, using the round-robin scheduling load balancing algorithm, an exception will be thrown if the call to the server fails.
documentation.user.method.desc.sync.roundrobin.failover=Pull an ID from the server. Synchronous call, using the round-robin scheduling load balancing algorithm, if the call to the server fails, it will try to call other server nodes.
documentation.user.method.desc.sync.consistenthash.failfast=Pull an ID from the server. Synchronous call, using consistent Hash load balancing algorithm, failure to call the server will throw an exception.
documentation.user.method.desc.sync.consistenthash.failover=Pull an ID from the server. Synchronous call, using consistent Hash load balancing algorithm, if the call to the server fails, it will try to call other server nodes.
documentation.user.method.desc.async.roundrobin.failfast=Pull an ID from the server. Asynchronous call, using the round-robin scheduling load balancing algorithm, an exception will be thrown if the call to the server fails.
documentation.user.method.desc.async.roundrobin.failover=Pull an ID from the server. Asynchronous call, using the round-robin scheduling load balancing algorithm, if the call to the server fails, it will try to call other server nodes.
documentation.user.method.desc.async.consistenthash.failfast=Pull an ID from the server. Asynchronous call, using consistent Hash load balancing algorithm, failure to call the server will throw an exception.
documentation.user.method.desc.async.consistenthash.failover=Pull an ID from the server. Asynchronous call, using consistent Hash load balancing algorithm, if the call to the server fails, it will try to call other server nodes.
documentation.user.method.parameter.key=key - Configured Key
documentation.user.method.parameter.attachments=attachments - annex. Only applicable to CR structure. The Key value in HashMap corresponds to the value of $dynamic() in CR Expression. For example, set map.put("one", "HI"), "HI" will replace the $dynamic(one) placeholder
documentation.user.method.parameter.sessionkey=sessionKey - The key of the session. Only used for consistent Hash load balancing
documentation.user.method.parameter.timeout=timeout - timeout
documentation.user.method.parameter.timesretry=timesRetry - Number of failover calls
documentation.user.method.parameter.callback=pullCallback - The result of the asynchronous callback, whether the result is a CR or NS structure depends on the configuration at the time of creation
documentation.user.method.return=The result of the synchronous pull, whether the result is CR or NS structure depends on the configuration at the time of creation
documentation.admin.title=Management-oriented
documentation.admin.method.desc.sync.createcomponent=Create a component. Synchronous call, failure to call the server will throw an exception.
documentation.admin.method.desc.sync.querycomponentsize=Query the total number of components. Synchronous call, failure to call the server will throw an exception.
documentation.admin.method.desc.sync.querycomponentbykey=Query component details according to Key. Synchronous call, failure to call the server will throw an exception.
documentation.admin.method.desc.sync.queryclusterlist=Query the cluster list. Synchronous call, failure to call the server will throw an exception.
documentation.admin.method.desc.sync.kickoutinvoker=Kick the Invoker out of the routing immediately. Synchronous call, failure to call the server will throw an exception.
documentation.admin.method.desc.sync.removeinvoker=Remove the Invoker from the cluster list. Synchronous call, failure to call the server will throw an exception.
documentation.admin.method.desc.sync.updateweight=Update Inovker's weight in routing immediately. Synchronous call, failure to call the server will throw an exception.
documentation.admin.method.parameter.component=component - component, choose one of CR structure and NS structure.
documentation.admin.method.parameter.nscomponent=component - component, Only applicable to NS structure.
documentation.admin.method.parameter.key=key - Key of the specified component
documentation.admin.method.parameter.kickedsid=kickedSid - Kicked sid
documentation.admin.method.parameter.sid=sid - Specified sid
documentation.admin.method.parameter.weight=weight - Updated weight value
documentation.admin.method.parameter.timeout=timeout - timeout
documentation.admin.method.return=The result of the synchronization response. After the operation is successful, the enumeration value SendStatus=SEND_OK
#design
design.introduction=The above model is the core architecture of the MyBerry distributed system. Here, you will understand the system design and key design indicators of MyBerry. Mastering these contents can help you to use MyBerry more easily.
design.system.design.summary.title=System Design Summary
design.system.design.summary.description=The system design outline shows the multi-level and multi-dimensional design elements, including a number of key designs, in terms of developer accessibility, operation and maintenance, and system performance, security, stability, and scalability. Among other features, it plays a vital role.
design.key.design.norm.title=Key Design Norm
design.key.design.norm.consistency=\u261BConsistency
design.key.design.norm.consistency.description=MyBerry distributed system architecture design has two very core designs, one of which is consistency. In a service, it is necessary to obtain a unique ID, and to ensure that the service can be the same as before the restart after an accidental restart. Therefore, the latest data must be written to the hard disk, and the operation of 'writing' into the hard disk is a necessary work. Generally speaking, to ensure the 'write' consistency of a distributed system loss high performance , even if the strong consistency of distributed transactions is not used, the final consistency of weak consistency is adopted. In high concurrency scenarios, its performance loss cannot be ignored. MyBerry cleverly circumvents this problem, not only can maintain consistency (unique) in a distributed environment, but also maintain high performance.
design.key.design.norm.consistency.question1=1. Q: How does MyBerry ensure unique ID generation and high performance in a distributed environment?
design.key.design.norm.consistency.answer1=A: The ID generated by MyBerry is composed of two key IDs. One is self-incrementing ID to ensure uniqueness in a single MyBerry instance; the other is SID, also called server id, named mySid in the configuration file. It is configured manually and is configured to ensure uniqueness. The combination of the two IDs can ensure that the generated ID is unique in a distributed environment and does not require communication between MyBerry instances to ensure uniqueness, avoiding the performance loss caused by network IO and consensus algorithms. Therefore, the MyBerry system design conforms to the AP in the CAP theorem.
design.key.design.norm.consistency.question2=2. Q: How does MyBerry ensure the consistency of file data?
design.key.design.norm.consistency.answer2=A: There are two instance roles in the MyBerry cluster, namely Leader and Learner. The generated rule data of the ID submitted by the client is only written by the leader, and then the leader synchronizes the rule data to the learner.
design.key.design.norm.availability=\u261BAvailability
design.key.design.norm.availability.description=The second core design of MyBerry is availability. One role of the leader is to write rule data. In the traditional architecture, the role of the leader is very similar to that of the master node of the master-slave architecture. The master node writes data, the slave node synchronizes data, and the client reads data from the slave node. Another function is to provide routing update services to clients. Leader will collect and organize routing information reported by Learner and synchronize it with all Learners. At this time, the role of Leader is to become the registration center of the cluster.
design.key.design.norm.availability.question1=1. Q: Is the MyBerry service available when some nodes accidentally lose contact?
design.key.design.norm.availability.answer1=A: Due to the existence of the registry, the client caches a routing table locally. When some nodes are unavailable, the normal running nodes will not be affected.
design.key.design.norm.availability.question2=2. Q: The leader has only one node. If the leader loses contact, will the service be unavailable?
design.key.design.norm.availability.answer2=A: The client caches a routing table locally. When the leader loses contact, the service still returns the call result normally. Until a new leader is re-elected, routing updates and submission of new rules are temporarily unavailable.
design.key.design.norm.partition.tolerance=\u261BPartition Tolerance
design.key.design.norm.partition.tolerance.description=Due to the foundation laid by consistency and availability, the design criteria for partition tolerance are a matter of course. Its characteristics give consideration to real-time and final consistency.
design.key.design.norm.partition.tolerance.question1=1. Q: What is the focus of the design of MyBerry partition tolerance?
design.key.design.norm.partition.tolerance.answer1=A: Since the partition tolerance only occurs when the rule is submitted, when the leader writes new rule data, it will immediately notify all learners to synchronize the new data rule to achieve real-time purpose. Sending new data rules is a memory-intensive action. MyBerry has made a trade-off between real-time performance and memory management, and cannot guarantee that new rule data will be sent successfully. Therefore, Learner will periodically synchronize new rule data with Leader.
design.key.design.norm.safety=\u261BSafety
design.key.design.norm.safety.question1=1. Q: How does MyBerry ensure the security of data during network transmission?
design.key.design.norm.safety.answer1=A: When the MyBerry instance transfers data with the client and other instances in the cluster, a private transfer protocol is used, and data information will not be exposed.
design.key.design.norm.safety.question2=2. Q: How does MyBerry guarantee the security of data storage?
design.key.design.norm.safety.answer2=A: Each MyBerry instance will generate a data file. When some instances are caused by irresistible factors, such as floods, fires and other natural disasters, data can be synchronized with the undamaged instances.
design.key.design.norm.stability=\u261BStability
design.key.design.norm.stability.question1=1. Q: How to ensure the stability of MyBerry instance in the cluster?
design.key.design.norm.stability.answer1=A: Each MyBerry instance can be configured with the maximum number of concurrent clients. After the maximum number of concurrent connections is exceeded, the request will be rejected. Each request will be written into the memory-mapped file after the ID is generated, and if the writing times out, the request will be rejected.
design.key.design.norm.stability.question2=2. Q: How to ensure the stability of MyBerry cluster?
design.key.design.norm.stability.answer2=A: Each MyBerry instance can be configured with routing weights. When all the instances are deployed in the same hardware environment, the configured weights are also the same. When the hardware environment of the instance deployment is different, the weight of the instance configuration with the higher hardware configuration will increase accordingly. The higher the weight, the higher the probability of the load balancing algorithm being invoked.
design.key.design.norm.performance=\u261BPerformance
design.key.design.norm.performance.question1=1. Q: What is the difference in performance design between MyBerry and traditional distributed ID generation algorithms?
design.key.design.norm.performance.answer1=A: The high performance of the distributed ID generation algorithm is guaranteed by the algorithm itself. Unlike the high performance of MyBerry, its high performance is guaranteed by the algorithm and architecture at the same time. Compared with the CR structure, the NS structure pays more attention to performance in design. In the CR structure, the client can only obtain one ID per call, and the network IO is more frequent. The NS structure retrieves one number segment at a time, which can effectively reduce network IO calls.
design.key.design.norm.performance.question2=2. Q: Compared with CR, NS has better performance. What is the performance of CR?
design.key.design.norm.performance.answer2=A: No matter which structure is used, the MyBerry generation process is almost a pure memory calculation, and the performance of CR is only weaker than that of NS.
#dev
dev.introduction=This article will introduce you how to connect MyBerry to your application from the shallower to the deeper. First, you need to learn to build the two structures of ID, CR and NS. You will feel the unique charms of the two structures in different the application scenario.
dev.cr.title=CR Structure
dev.cr.description=Using CR (Cooperative Redundancy) structure, you can flexibly arrange the rules of ID construction. With the characteristics of MyBerry Expression, you can design a fixed-length ID template to realize your own ideas.
dev.cr.expression.introduction=MyBerry Expression is a template engine independently designed for CR structure, which has multiple elements, all of which are one of the mandatory and non-required options. The required option requires that any MyBerry Expression constructed must be included in order to pass the server's validation when submitted to the server. The following is a list of all elements.
dev.cr.expression.keyword=Keyword
dev.cr.expression.description=Description
dev.cr.expression.required=Required
dev.cr.expression.sid.description=Server ID digit subscript getter. e.g., the server ID of the current request is 167, #sid(0) is equal to 7, #sid(1) is equal to 6, and #sid(2) is equal to 1.
dev.cr.expression.incr.description=Increment sequence digit subscript getter. The rule is the same as #sid(). After the index exceeds the actual number of digits, it is filled with 0.
dev.cr.expression.time.description=Resets the auto increment sequence by the specified time unit. For example, #time(day) means reset the auto-increment sequence to 0 every new day. The currently supported time units are: day, month, year.
dev.cr.expression.rand.description=Gets a random number by the specified number of digits. For example, #rand(3) means get a 3-digit random number.
dev.cr.expression.dynamic.description=Pass parameters dynamically. For example, $dynamic(hi) means that one of the keys of the attachment Map is the string hi.
dev.cr.expression.base.description=Specify a single digit or a single uppercase and lowercase letter.
dev.cr.expression.example.description=To design an ID construction template, the maximum value of the current server ID is known to be 3 digits. The auto-incrementing sequence is designed to be 5 digits. The auto-incrementing sequence can be reset by day to meet the current needs. A fixed number 9 and the letter m are added to indicate a special meaning. In order to prevent the auto-incrementing sequence from exceeding the capacity in extreme cases, a 3-digit random number is added to reduce collisions. Finally, a value is dynamically passed in from the client to indicate a special meaning.
dev.cr.create.introduction=Now we use myberry-console to create a CR component for the above example.
dev.cr.search.introduction=After submission, we check whether the creation is successful through key query.
dev.cr.get.introduction=After successfully creating the CR component, connect to MyBerry in the application and pull a new ID from the remote server synchronously.
dev.ns.title=NS Structure
dev.ns.description=Using the NS (Number Segment) structure, each remote call can obtain a continuous number interval. Any number in the interval can be combined with the collaboration ID to construct a unique ID to cache locally. Each time the ID is obtained, it is preferentially obtained from the local. When the local ID is not enough, a new interval is pulled from the remote again to reduce the number of remote calls and improve user system performance.
dev.ns.reset.type.description=According to the real scene, choose a reasonable reset strategy and avoid endless use until all the numbers are exhausted. The reset strategies currently supported are:
dev.ns.reset.type.strategy.id=Strategy ID
dev.ns.reset.type.strategy.description=Strategy Description
dev.ns.reset.type.0.description=No strategy.
dev.ns.reset.type.1.description=Every new day, the interval is reset to the initial value.
dev.ns.reset.type.2.description=Every new month, the interval is reset to the initial value.
dev.ns.reset.type.3.description=Every new year, the interval is reset to the initial value.
dev.ns.set.example.description=Set the start value of the interval to 100 and the step size to 5 (the start value of the interval for the first pull is 100, the end value is 104, the start value of the interval for the second pull is 105, and the end value 109), the reset policy is set to reset every day, which can meet the real needs.
dev.ns.create.introduction=Now we use myberry-console to create a NS component for the above example.
dev.ns.search.introduction=After submission, we check whether the creation is successful through key query.
dev.ns.get.introduction=After successfully creating the NS component, connect to MyBerry in the application and pull a new ID range from the remote server synchronously.
dev.capacity.design.title=Capacity Design
dev.capacity.design.description=The essence of the unique ID structure is to create disposable consumables, the more you use, the less you have left. Therefore, capacity design is very important. In MyBerry, there are three important indicators to be carefully considered.
dev.capacity.design.sid=\u261EServer ID
dev.capacity.design.sid.description=As traffic increases, capacity expansion is essential. The ID constructed in the CR structure has a fixed length. When the number of server ID digits increases, the ID generated by the CR may collide. In order to avoid this situation, when designing the ID construction rules in the CR structure, the SID should reserve a spare place. For example, for clusters with SIDs 2, 3, and 4, the generation rule reserves two free places '#sid(2) #sid(1) #sid(0)'. If the SID of the cluster is expanded to 3 digits, the SID is 100 It can also guarantee that there will be no collisions.
dev.capacity.design.incr=\u261EAutoincrement Sequence
dev.capacity.design.incr.description=The capacity of the auto-incrementing sequence is closely related to the user scenario requirements. For example, if there are 3 instances in the current cluster, the length of the auto-incrementing sequence is limited to 4, that is, from 0000 to 9999. Then, a maximum of 20000 = 10000 * (3-1) IDs can be produced per day.
dev.capacity.design.reset.type=\u261EReset Type
dev.capacity.design.reset.type.description=Corresponding to the auto-increment sequence, the capacity is restored to the maximum after each reset.
dev.spring.title=Spring Integration
dev.spring.introduction=If you are using the spring framework, you can easily integrate MyBerry into the spring framework.
#ops
ops.introduction=This article will give you a detailed introduction on how to deploy and maintain MyBerry.
ops.install.title=Install
ops.install.description1=MyBerry is distributed in source code. Before installing, you first need to compile the source code into a binary file.
ops.install.description2=Before compiling MyBerry, you need to install Maven and JDK1.8 to ensure the compilation environment.
ops.install.compile.compression=\u25B7Compile And Package
ops.install.decompression=\u25B7Decompression Installation
ops.configuring.title=Configure
ops.configuring.introduction1=This note explains several important properties of 
ops.configuring.introduction2=, and the effect of each property in the system.
ops.configuring.property.name=Property Name
ops.configuring.default.value=Default Value
ops.configuring.details=Details
ops.configuring.required=Required
ops.configuring.listenport.details=Client connection port.
ops.configuring.mysid.details=server id. Required when setting up a cluster. Each instance needs to be configured with a different 'mySid'.
ops.configuring.haserveraddr.details=Highly available address. Required when setting up a cluster. Configure it according to 'mySid@ip:haPort'. 'haPort' is a highly available port and cannot be the same as 'listenPort'. Each node in the cluster is separated by a comma.
ops.configuring.storepath.details=Data file storage path.
ops.configuring.weight.details=Load balancing weight value.
ops.configuring.password.details=Administrator password. The connection password configured for the administrator client.
ops.configuring.writebackenabled.details=Configure the write-back switch. When 'haServerAddr' and 'weight' change, whether to write the changed data into the configuration file.
ops.configuring.cluster=\u25C6Cluster configuration
ops.configuring.cluster.details=To configure the cluster, the following parameters are required.
ops.configuring.multi.instance=\u25C6Single machine multi-instance configuration
ops.configuring.multi.instance.details=Try to deploy multiple instances on a single machine. In addition to the mandatory configuration of the cluster, the configuration of multiple paths also needs to be explicitly specified instead of the default configuration.
ops.configuring.multi.instance.edit=Edit
ops.configuring.multi.instance.path=and configure it with an absolute path:
ops.run.title=Run
ops.run.description=Before running MyBerry, you need to prepare environment variables for Java and MyBerry.
ops.run.env.edit=Edit file
ops.run.jvm.shell=Edit Shell
ops.run.jvm.options=set JVM options
ops.run.server=Start Server
ops.run.help=Want to get more startup help from MyBerry? Please execute the following command.
ops.console.title=Console
ops.console.description1=If you have successfully run MyBerry cluster, in order for you to quickly get started with MyBerry, we have made a case 
ops.console.description2=, you can experience the role of related APIs in this visual case.
ops.settings=\u25C6Add configuration
ops.settings.description1=Edit configuration file
ops.settings.description2=, fill in 'serverAddr'(ip:listenPort) and 'password'.
ops.console.building.and.run=\u25C6Building&Run
ops.console.building=\u25B7Building
ops.console.run=\u25B7Run
ops.console.example=\u25C6Example
ops.console.home=After successful startup, open the console homepage, you can view the current cluster status, including node status (Total Nodes = Leader + Learner + Lost) and data synchronization status.
ops.console.weight=When the application is deployed in server instances with different hardware configurations, reasonable setting of routing weights is of great help to the overall performance and stability of the system. When the weight value is modified, the real weight of the route takes effect within 1 minute at most.
ops.console.block.file=When you want to query specific data synchronization monitoring results, open the block file details of the corresponding instance and view the block file list.
ops.console.extend=This is the end of the introduction to monitoring. Next, I will introduce how MyBerry cluster can achieve graceful scaling without the user's perception.
ops.console.expansion=\u25C6Expansion
ops.console.expansion.introduction1=To add a new instance to a known cluster, you must first know some basic information of the known cluster. Here, taking the SID 2, 3, and 4 of the known cluster as an example, we plan to add the new instance of SID 5 to the cluster.The current cluster configuration is as follows:
ops.console.expansion.introduction2=To add a new instance to a known cluster, the new instance configuration needs to include three necessary conditions, one is that the SID of the new instance is different from the SID of any instance in the known cluster, and the other is that the known cluster must be included in the 'haServerAddr' More than half of the addresses and the new instance's own high-availability address, the third is that the two parameter configurations of 'blockFileSize' and 'maxSyncDataSize' must be the same as the known cluster. 'blockFileSize' and 'maxSyncDataSize' have default values. In the case of no display statement, all instances are the same. Therefore, the configuration of the new instance with SID 5 is as follows:
ops.console.shrink=\u25C6Shrink
ops.console.shrink.introduction=The elegance of MyBerry cluster scaling is mainly reflected in the shrinking. The user is completely unaware of the execution of the whole process, and there will be no abnormalities. Removing instances from known clusters is a rigorous action. Therefore, please strictly follow the steps below:
ops.console.shrink.description1=Step 1: Select the instance to be removed, here we take the SID of 4 as an example, and kick out the instance with SID of 4.
ops.console.shrink.description2=Step 2: After the kicking action is executed, the operation status of the instance with SID 4 becomes 'remove' and the status is temporarily unavailable.
ops.console.shrink.description3=Step 3: At this point, you need to pay special attention. You need to wait at least 1 minute, and then execute the script to safely shut down the instance with SID 4.
ops.console.shrink.description4=Step 4: After safely shutting down the instance, wait for 2 minutes, refresh the page to 'remove' the status and become available.
ops.console.shrink.description5=Then remove the instance with SID 4.
ops.console.shrink.description6=Finally, the instance with the SID of 4 has been unable to find the monitoring information, and the entire removal action is completed.
#performance
performance.introduction=If you plan to use MyBerry in a production environment, here will provide you with some performance test reports. These reports may be displayed in a separate module or as a result of the system as a whole, so that you can fully understand the performance of MyBerry and provide you with more Comprehensive reference basis to facilitate your overall assessment.
performance.codec.title=Codec
performance.codec.introduction=The codec framework LightCodec independently designed by MyBerry draws on the advantages of the heap buffer, creates a flexible buffer, and realizes the overall structure of the source code is concise and easy to read. Compared with the familiar open source codec framework of the same type, the performance of LightCodec is also Favorably.
performance.codec.test.description=The following is a line chart of the time required to perform a fixed number of serialization and deserialization. The test process includes the initialization of serialized objects.
performance.instance.title=Instance
performance.instance.introduction=In order to test the performance of MyBerry single instance, the following is a local test of the client in an 8-core CPU, win64 operating system environment, single-threaded continuous calling of MyBerry instance.
performance.instance.test.description=Analysis: Calling 1000, 10000, 30000, 50000, 100000 times takes 407 milliseconds, 1591 milliseconds, 3599 milliseconds, 5097 milliseconds, and 9638 milliseconds respectively. The maximum pressure of a single thread is 100,000 continuous calls and an average response of 10.38 times per millisecond. Because it is local environmental testing, the results did not include the performance loss caused by network IO.
#faq
faq.description=In case of problems, you can try to find the answer below. Didn't find the answer?
faq.question1=1. What is MyBerry's default character encoding?
faq.answer1=MyBerry uses UTF-8 as the default character encoding.
faq.question2=2. Which operating systems is MyBerry compatible with?
faq.answer2=Windows, MacOS, Linux
faq.question3=3. What versions of the JDK does MyBerry support?
faq.answer3=JDK1.8
faq.question4=4. Can IDs output in CR structure and NS structure be unique?
faq.answer4=Within the user's predicted output range, it is guaranteed to be absolutely unique. In fact, for a fixed-length ID, under the limited character composition, there will always be a chance to repeat in extreme situations no matter what kind of service is used or what kind of algorithm is constructed. 
faq.question5=5. Are the IDs output in CR structure and NS structure uniform?
faq.answer5=It is theoretically uniform. The CR structure uses a monotonically increasing method, which is increased by one for each request. NS structure generates one interval at a time, and multiple intervals are also continuous.
faq.question6=6. Admin's API is exposed, is there a security risk?
faq.answer6=The Admin and User APIs differ. The Admin request has a password to verify the request authorization. The user with the User permission does not have a password and cannot operate the Admin API.
faq.question7=7. Does the cluster node support horizontal scaling?
faq.answer7=stand by. Horizontal expansion can not only improve the carrying capacity of the cluster, but also expand the capacity of the ID pool.
faq.question8=8. When adding a new instance to an already running cluster, why is the new instance not added successfully?
faq.answer8=Firstly, eliminate configuration errors one by one, and secondly eliminate data file errors. If there are no errors in the first two items, check whether there are any missing instances in the cluster. If existed, safely kick out the missing instances before adding new instances.
#thanks
thanks.content=Without the help of my classmates and friends, MyBerry will not be able to present to you in such a short time. I would like to take this opportunity to thank all my classmates and friends.
name1=Liang Dong
contribution1=Logo designer
current.residence1=China
name2=Yang JunFang
contribution2=Eng. translator
current.residence2=Singapore